type Drink {
  id: ID!
  name: String!             # a beer
  mixture: [Portion!]        # 1 beer
  instructions: String!     # serve in a litre stein
}

type Portion {
  id: ID!
  category: Category!     # beer (this is a category)
  flavor: String?         # N/A
  amount: String!         # 1 can
  default: Ingredient!    # brands facet? # suggested options?
}

type Category {
  id: ID!
  parent: Category?         # null       / beer
  name: String!             # beer       / porter
  children: [Category!]     # back ref for categories
}

type Ingredient {
  id: ID!
  categories: [Category!] # beer       beer
  name: String!           # blue moon  guiness
  flavor: String          # orange     null      ? should it be a category/ies?
}

type Stock {
  id: ID!
  ingredient: Ingredient! # beer
  uses: Int!              # 2 (meaning 2 cans/bottle/cups)
}

type Rating {
  id: ID!
  ingredient: Ingredient! # blue moon
  rating: Int!            # 0-10 ints (may change)
}

type Order {
  id: ID!
  user: User!                 # who ordered /// have who made it?
  drink: Drink!               # recipe
  ingredients: [Ingredient!]!  # actual ingredients to use
  status: String!             # enum (in progress,canceled,complete...)
  user_instructions: String  # user specfic instructions
  completed: Bool!            # is the order done with it's lifecycle (created/cancelled)? (long term storage)
}


type User {
  id: ID!
  name: String!
  orders: [Order!]
}

type Query {
  me: User
  drinks(ingredients: [ID!], categories: [ID!], name: String): [Drink!]
  categories: [Category!]
  orders: [Order!] # maybe just a filter from the user object?
  currentOrders: [Order!]
}

type Input { # temporarily unused, will at least hold filter params

}

type Mutation {
  orderDrink(drink: ID!, ingredients: [ID!]!, instructions: Sting?): Order
  setOrderState(order: ID!, state: String!): Order # state should transition to an enum
  progressOrder(order: ID!): Order
  cancelOrder(order: ID!): Order
}
