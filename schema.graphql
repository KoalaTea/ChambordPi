type Drink {
  id: ID!
  name: String!             # a beer
  mixture: [Portion]        # 1 beer
  instructions: String!     # serve in a litre stein
}

type Portion {
  id: ID!
  category: Category!     # beer (this is a category)
  flavor: String?         # N/A
  amount: String!         # 1 can
  default: Ingredient!    # brands facet? # suggested options?
}

type Category {
  id: ID!
  larger_category: Category?  # null       / beer
  name: String!               # beer       / porter
  categories: [Category]?     # back ref for categories
}

type Ingredient {
  id: ID!
  categories: [Category] # beer       beer
  name: String!          # blue moon  guiness
  flavor: String?        # orange     null
}

type Stock {
  id: ID!
  ingredient: Ingredient! # beer
  uses: Int!              # 2 (meaning 2 cans/bottle/cups)
}

type Rating {
  id: ID!
  ingredient: Ingredient! # blue moon
  rating: Int!            # 2.75 / 0-5
}

type Order {
  id: ID!
  user: User!                 # who ordered /// have who made it?
  drink: Drink!               # recipe
  ingredients: [Ingredient]!  # actual ingredients to use
  status: String!             # enum (in progress,canceled,complete...)
  user_instructions: String?  # user specfic instructions
  completed: Bool!            # is the order done with it's lifecycle (created/cancelled)? (long term storage)
}


type User {
  id: ID!
  name: String!
  orders: [Order]
}

type Query {
  me: User
  drinks: [Drink]
  orders: [Order]
  currentOrders: [Order]
}

type Input {

}

type Mutation {
  orderDrink(drink: ID!, ingredients: [ID]!, instructions: Sting?)
  setOrderState(order: ID!, state: String!) # state should transition to an enum
  progressOrder(order: ID!)
  cancelOrder(order: ID!)
}